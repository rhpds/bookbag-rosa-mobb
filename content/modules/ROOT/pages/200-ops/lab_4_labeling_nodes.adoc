== Introduction

Labels are a useful way to select which nodes that an application will run on. These nodes are created by machines which are defined by the MachineSets we worked with in previous sections of this workshop. An example of this would be running a memory intensive application only on a specific node type.

While you can directly add a label to a node, it is not recommended because nodes can be recreated, which would cause the label to disappear. Therefore we need to label the Machine pool itself.

== Set a label for the Machine Pool

. Just like the last section, let's use the default worker machine pool to add our label. We will add the label "tier=frontend" to nodes in this machine pool.
To do so, run the following command:
+
[source,sh,role=execute]
----
rosa edit machinepool workers -c rosa-${GUID} --labels tier=frontend --replicas=3
----
+
.Sample Output
[source,text,options=nowrap]
----
I: Updated machine pool 'workers' on hosted cluster 'rosa-9p6dc'
----

NOTE: Only NEW nodes will be labeled.

. Now, let's verify the machine pool is labeled.
To do so, run the following command:
+
[source,sh,role=execute]
----
rosa describe machinepool workers -c rosa-$GUID

ID:                         workers
Cluster ID:                 2aab2ivftv9tjkglqudhhi7r0799ull4
Autoscaling:                No
Desired replicas:           3
Current replicas:           2
Instance type:              m5.xlarge
Labels:                     tier=frontend
Taints:
Availability zone:          us-east-2a
Subnet:                     subnet-050acbde792665f19
Version:                    4.14.17
Autorepair:                 Yes
Tuning configs:
Message:
----

. Wait for a while for the new node to be created, by running the following command:
+
[source,sh,role=execute]
----
watch 'oc get nodes --selector='tier=frontend' -o name'
----
+
.Sample Output
[source,text,options=nowrap]
----
node/ip-10-0-133-248.us-east-2.compute.internal
----

NOTE: Only one node will be labeled, the other two nodes in the machine pool will not be labeled.
They must be labeled manually, or deleted and recreated.

== Deploy an app to the labeled nodes

Now that you've successfully labeled a node, deploy a workload to demonstrate app placement using `nodeSelector`.
This should force the app to only deploy on your labeled node.

. First, create a project (or namespace) for the application.
To do so, run the following command:
+
[source,sh,role=execute]
----
oc new-project nodeselector-ex
----
+
.Sample Output
[source,text,options=nowrap]
----
Now using project "nodeselector-ex" on server "https://api.rosa-9p6dc.2eu0.p3.openshiftapps.com:443".

You can add applications to this project with the 'new-app' command. For example, try:

    oc new-app rails-postgresql-example

to build a new example application in Ruby. Or use kubectl to deploy a simple Kubernetes application:

    kubectl create deployment hello-node --image=registry.k8s.io/e2e-test-images/agnhost:2.43 -- /agnhost serve-hostname
----

. Next, deploy the application and associated resources that will target the labeled node.
To do so, run the following command:
+
[source,sh,role=execute]
----
cat << EOF | oc apply -f -
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: nodeselector-app
  namespace: nodeselector-ex
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nodeselector-app
  template:
    metadata:
      labels:
        app: nodeselector-app
    spec:
      nodeSelector:
        tier: frontend
      containers:
      - name: hello-openshift
        image: "docker.io/openshift/hello-openshift"
        ports:
        - containerPort: 8080
          protocol: TCP
        - containerPort: 8888
          protocol: TCP
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
EOF
----
+
.Sample Output
[source,text,options=nowrap]
----
deployment.apps/nodeselector-app created
----

. Now, validate that the application has been deployed to one of the labeled nodes.
To do so, run the following command:
+
[source,sh,role=execute]
----
oc -n nodeselector-ex get pod -l app=nodeselector-app -o json \
  | jq -r .items[0].spec.nodeName
----
+
.Sample Output
[source,text,options=nowrap]
----
node/ip-10-0-252-142.us-east-2.compute.internal
----

. Double check the name of the node to compare it to the output above to ensure the node selector worked to put the pod on the correct node.
+
[source,sh,role=execute]
----
oc get nodes --selector='tier=frontend' -o name
----
+
.Sample Output
[source,text,options=nowrap]
----
node/ip-10-0-0-65.us-east-2.compute.internal
----

. Next create a `service` using the `oc expose` command
+
[source,sh,role=execute]
----
oc expose deployment nodeselector-app
----
+
.Sample Output
[source,text,options=nowrap]
----
service/nodeselector-app exposed
----

. Expose the newly created `service` with a `route`
+
[source,sh,role=execute]
----
oc create route edge --service=nodeselector-app  --insecure-policy=Redirect
----
+
.Sample Output
[source,text,options=nowrap]
----
route/nodeselector-app created
----

. Fetch the URL for the newly created `route`
+
[source,sh,role=execute]
----
oc get routes/nodeselector-app -o json | jq -r '.spec.host'
----
+
.Sample Output
[source,text,options=nowrap]
----
nodeselector-app-nodeselector-ex.apps.rosa.rosa-9p6dc.2eu0.p3.openshiftapps.com
----
+
Then visit the URL presented in a new tab in your web browser.
+
Note that the application is exposed over the default ingress using a predetermined URL and trusted TLS certificate.
This is done using the OpenShift `Route` resource which is an extension to the Kubernetes `Ingress` resource.

Congratulations!

You've successfully demonstrated the ability to label nodes and target those nodes using `nodeSelector`.

== Summary

Here's you learned:

* Add labels to Machine Pools
* Deploy an application on nodes with certain labels using nodeSelector
